#!/usr/bin/python

import os
import sys
import argparse
import time
import uuid
import subprocess
import socket
import json
import yaml
import requests
import pprint
from vnc_api import vnc_api
from vnc_api.gen import resource_client
from vnc_api.gen import resource_xsd
from cfgm_common import _obj_serializer_all

sriov_physical_network = 'sriov'

default_args = [
    ('auth-username', 'admin'),
    ('auth-password', 'contrail123'),
    ('auth-tenant', 'admin'),
    ('auth-domain', 'default'),
    ('auth-region', 'RegionOne'),
    ('auth-server', '127.0.0.1'),
    ('auth-url', '/v3/auth/tokens'),
    ('api-server', '127.0.0.1'),
    ('domain', 'default-domain'),
    ('tenant', 'admin')]


class ConfigConnect():
    def __init__(self, args):
        self.controller = args.api_server
        self.vnc = vnc_api.VncApi(username = args.auth_username,
                password = args.auth_password, tenant_name = args.auth_tenant,
                domain_name = args.auth_domain,
                api_server_host = args.api_server,
                auth_host = args.auth_server, auth_url = args.auth_url)
        try:
            self.tenant = self.vnc.project_read(
                    fq_name = [args.domain, args.tenant])
        except:
            self.tenant = None

class SriovCli():
    def __init__(self):
        self.vnc = None
        self.tenant = None

    def env(self, *args, **kwargs):
        for arg in args:
            value = os.environ.get(arg, None)
            if value:
                return value
        return kwargs.get('default', '')

    def openstack_cli(self, os_args):
        env = '/var/lib/kolla/config_files/admin-openrc.sh'
        cmd = 'docker exec kolla_toolbox bash -c "source %s; openstack %s"' \
                %(env, os_args)
        p = subprocess.Popen(cmd, stdout = subprocess.PIPE, shell = True)
        return p.stdout.read()

    def update_network(self, name):
        print '\nCheck virtual network %s...' %name
        try:
            obj = self.vnc.virtual_network_read(
                    fq_name = self.tenant.fq_name + [name])
        except Exception as e:
            print 'ERROR: %s' %(str(e))
            return
        pp = obj.get_provider_properties()
        if pp and (pp.physical_network == sriov_physical_network) and \
                (pp.segmentation_id == obj.virtual_network_network_id):
            print 'Skip.'
        else:
            print 'Update virtual network %s...' %name
            pp = vnc_api.ProviderDetails(obj.virtual_network_network_id,
                    sriov_physical_network)
            obj.set_provider_properties(pp)
            self.vnc.virtual_network_update(obj)

    def create_vm_port(self, args):
        print '\nCreate VM port...'
        id = str(uuid.uuid4())
        vmi = vnc_api.VirtualMachineInterface(name = id,
                parent_obj = self.tenant)
        vmi.uuid = id
        vn = self.vnc.virtual_network_read(
                fq_name = self.tenant.fq_name + [args.network])
        vmi.set_virtual_network(vn)
        kvp_list= [
                {
                    'key': 'profile',
                    'value': '{"physical_network": "sriov"}'
                },
                {
                    'key': 'host_id',
                    'value': 'null'
                },
                {
                    'key': 'vnic_type',
                    'value': 'direct'
                },
                {
                    'key': 'vif_details',
                    'value': '{"port_filter": true, "vlan": "10"}'
                },
                {
                    'key': 'vif_type',
                    'value': 'hw_veb'
                }
            ]
        kvps = vnc_api.KeyValuePairs()
        for kvp in kvp_list:
            kvps.add_key_value_pair(vnc_api.KeyValuePair(key = kvp['key'],
                    value = kvp['value']))
        vmi.set_virtual_machine_interface_bindings(kvps)
        try:
            self.vnc.virtual_machine_interface_create(vmi)
        except Exception as e:
            print 'ERROR: %s' %(str(e))
            return
        print 'VM port %s is created.' %id

        print '\nAllocate instance IP address...'
        id = str(uuid.uuid4())
        ip = vnc_api.InstanceIp(name = id)
        ip.uuid = id
        ip.add_virtual_machine_interface(vmi)
        ip.add_virtual_network(vn)
        try:
            self.vnc.instance_ip_create(ip)
        except Exception as e:
            print 'ERROR: %s' %(str(e))
            return
        ip = self.vnc.instance_ip_read(id = id)
        print 'IP address %s is allocated.' %ip.get_instance_ip_address()
        return vmi.uuid

    def launch_vm(self, name, port_id):
        print '\nLaunch VM on port %s...' %port_id
        os_args = 'server create --image centos --flavor m1.small ' + \
                '--port %s --availability-zone az-1 %s' %(port_id, name)
        self.openstack_cli(os_args)

        while (1):
            os_args = 'server show %s -c status -f value' %name
            vm_state = self.openstack_cli(os_args).rstrip()
            print 'VM State: %s' %vm_state
            if vm_state == 'ACTIVE':
                break
            time.sleep(5)

    def get_device_info(self, api_server, compute):
        print 'Get device and port...'
        url = 'http://%s:8081/analytics/uves/prouters' %api_server
        response = requests.get(url)
        dev_list = response.json()
        for dev in dev_list:
            print 'Check device %s...' %dev['name']
            dev_resp = requests.get(dev['href'])
            dev_body = dev_resp.json()
            lldp_table = dev_body['PRouterEntry']['lldpTable']
            for r in lldp_table['lldpRemoteSystemsData']:
                if r['lldpRemSysName'] == compute:
                    break
            else:
                continue
            break
        else:
            print 'ERROR: Not found device and port for %s!' %compute
            return

        for l in lldp_table['lldpLocalSystemData']['lldpLocPortTable']:
            if l['lldpLocPortNum'] == r['lldpRemLocalPortNum']:
                break
        else:
            print 'ERROR: Not found local port for %s!' %compute
            return
        return dev_body, l['lldpLocPortId']

    def create_device_port(self, args):
        print '\nCreate device port...'
        print 'Get VM ID...'
        os_args = 'server show %s -c id -f value' %args.name
        vm_id = self.openstack_cli(os_args).rstrip()
        vm = self.vnc.virtual_machine_read(id = vm_id)
        print '%s' %vm_id

        print 'Get compute node...'
        os_args = 'server show %s -c "OS-EXT-SRV-ATTR:host" -f value' \
                %args.name
        compute = self.openstack_cli(os_args).rstrip()
        print '%s' %compute

        dev_body, dev_port = self.get_device_info(args.api_server, compute)
        if not dev_body:
            print 'ERROR: Not found device for %s!' %compute
            return
        conf = dev_body['ContrailConfig']['elements']
        fabric_fqn = json.loads(conf['fabric_refs'])[0]['to']
        dev_name = json.loads(conf['fq_name'])[1]
        print 'device name: %s' %dev_name
        print 'device port: %s' %dev_port
        print 'fabric: %s' %fabric_fqn
        return

        id = str(uuid.uuid4())
        vmi = vnc_api.VirtualMachineInterface(name = id,
                parent_obj = self.tenant)
        vmi.uuid = id
        vn = self.vnc.virtual_network_read(
                fq_name = self.tenant.fq_name + [args.network])
        vmi.set_virtual_network(vn)
        vmi.set_virtual_machine(vm)
        kvp_list= [
                {
                    'key': 'profile',
                    'value': '{"physical_network": "sriov"}'
                },
                {
                    'key': 'host_id',
                    'value': 'null'
                },
                {
                    'key': 'vnic_type',
                    'value': 'direct'
                },
                {
                    'key': 'vif_details',
                    'value': '{"port_filter": true, "vlan": "10"}'
                },
                {
                    'key': 'vif_type',
                    'value': 'hw_veb'
                }
            ]
        kvps = vnc_api.KeyValuePairs()
        for kvp in kvp_list:
            kvps.add_key_value_pair(vnc_api.KeyValuePair(key = kvp['key'],
                    value = kvp['value']))
        vmi.set_virtual_machine_interface_bindings(kvps)
        try:
            self.vnc.virtual_machine_interface_create(vmi)
        except Exception as e:
            print 'ERROR: %s' %(str(e))
            return
        print 'VM port %s is created.' %id

    def cmd_launch_vm(self, args):
        print '\nLaunch SRIOV VM...'
        if not args.network:
            print 'ERROR: Argument "network" is missing!'
            return
        self.update_network(args.network)
        port_id = self.create_vm_port(args)
        if not port_id:
            return
        self.launch_vm(args.name, port_id)
        self.create_device_port(args)

    def cmd_delete_vm(self, args):
        print '\nDelete SRIOV VM...'
        os_args = 'server show %s -c id -f value' %args.name
        vm_id = self.openstack_cli(os_args).rstrip()
        vm = self.vnc.virtual_machine_read(id = vm_id)
        vmi_ref_list = vm.get_virtual_machine_interface_back_refs()
        os_args = 'server delete %s' %args.name
        self.openstack_cli(os_args).rstrip()
        for vmi_ref in vmi_ref_list:
            print 'Delete port %s' %vmi_ref['uuid']
            vmi = self.vnc.virtual_machine_interface_read(id = vmi_ref['uuid'])
            iip_ref_list = vmi.get_instance_ip_back_refs()
            if iip_ref_list:
                for iip_ref in iip_ref_list:
                    self.vnc.instance_ip_delete(id = iip_ref['uuid'])
            self.vnc.virtual_machine_interface_delete(id = vmi_ref['uuid'])

    def parser_init(self):
        parser = argparse.ArgumentParser()
        self.parser = parser
        parser.add_argument('--auth-username', help = 'User name')
        parser.add_argument('--auth-password', help = 'Password')
        parser.add_argument('--auth-tenant', help = 'Auth tenant name')
        parser.add_argument('--auth-domain', help = 'Auth domain name')
        parser.add_argument('--auth-region', help = 'Region name')
        parser.add_argument('--auth-server', help = 'Auth server address')
        parser.add_argument('--auth-url', help = 'Auth URL')
        parser.add_argument('--api-server', help = 'API server address')
        parser.add_argument('--domain', help = 'Domain name')
        parser.add_argument('--tenant', help = 'Tenant name')

        parser.add_argument('cmd', help = 'Command')
        parser.add_argument('name', help = 'Name')
        parser.add_argument('--network', help = 'Virtual network')

    def start(self):
        self.parser_init()
        args = self.parser.parse_args()
        #print 'args: %s' %args
        connect = ConfigConnect(args)
        self.vnc = connect.vnc
        self.tenant = connect.tenant
        cmd_map = {'launch-vm': self.create_device_port,
                   'delete-vm': self.cmd_delete_vm}
        func = cmd_map.get(args.cmd)
        if func:
            func(args)
        else:
            print 'ERROR: Command %s is invalid!' %args.cmd


if __name__ == '__main__':
    for arg in default_args:
        if not ('--' + arg[0]) in sys.argv:
            env_v = os.environ.get(arg[0].upper().replace('-', '_'))
            if env_v:
                arg_v = env_v
            else:
                arg_v = arg[1]
            sys.argv.insert(1, ('--' + arg[0]))
            sys.argv.insert(2, arg_v)
    SriovCli().start()

