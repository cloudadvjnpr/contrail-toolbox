#!/usr/bin/python

import os
import sys
import argparse
import time
import uuid
import subprocess
import socket
import json
import yaml
import requests
import pprint
import paramiko
from vnc_api import vnc_api
from vnc_api.gen import resource_client
from vnc_api.gen import resource_xsd
from cfgm_common import _obj_serializer_all

compute_username = 'root'
compute_password = 'c0ntrail123'
sriov_physical_network = 'sriov'

default_args = [
    ('auth-username', 'admin'),
    ('auth-password', 'contrail123'),
    ('auth-tenant', 'admin'),
    ('auth-domain', 'default'),
    ('auth-region', 'RegionOne'),
    ('auth-server', '127.0.0.1'),
    ('auth-url', '/v3/auth/tokens'),
    ('api-server', '127.0.0.1'),
    ('domain', 'default-domain'),
    ('tenant', 'admin')]


class ConfigConnect():
    def __init__(self, args):
        self.controller = args.api_server
        self.vnc = None
        try:
            self.vnc = vnc_api.VncApi(
                    username = args.auth_username,
                    password = args.auth_password,
                    tenant_name = args.auth_tenant,
                    domain_name = args.auth_domain,
                    api_server_host = args.api_server,
                    auth_host = args.auth_server,
                    auth_url = args.auth_url)
        except:
            print 'ERROR: Failed to connect to configuration API server!'
            return
        try:
            self.tenant = self.vnc.project_read(
                    fq_name = [args.domain, args.tenant])
        except:
            self.tenant = None

class SriovCli():
    def __init__(self):
        self.vnc = None
        self.tenant = None

    def env(self, *args, **kwargs):
        for arg in args:
            value = os.environ.get(arg, None)
            if value:
                return value
        return kwargs.get('default', '')

    def openstack_cli(self, os_args):
        env = '/var/lib/kolla/config_files/admin-openrc.sh'
        cmd = 'docker exec kolla_toolbox bash -c "source %s; openstack %s"' \
                %(env, os_args)
        p = subprocess.Popen(cmd, stdout = subprocess.PIPE, shell = True)
        return p.stdout.read()

    def update_network(self, name):
        print '\n# Check virtual network %s...' %name
        try:
            obj = self.vnc.virtual_network_read(
                    fq_name = self.tenant.fq_name + [name])
        except Exception as e:
            print 'ERROR: %s' %(str(e))
            return
        pp = obj.get_provider_properties()
        if pp and (pp.physical_network == sriov_physical_network) and \
                (pp.segmentation_id == obj.virtual_network_network_id):
            print 'Skip.'
        else:
            print '# Update virtual network %s...' %name
            pp = vnc_api.ProviderDetails(obj.virtual_network_network_id,
                    sriov_physical_network)
            obj.set_provider_properties(pp)
            self.vnc.virtual_network_update(obj)
        return obj

    def create_vm_port(self, args, vn_obj):
        print '\n# Create VM port...'
        id = str(uuid.uuid4())
        vmi = vnc_api.VirtualMachineInterface(name = id,
                parent_obj = self.tenant)
        vmi.uuid = id
        vmi.set_virtual_network(vn_obj)
        vlan_id = vn_obj.get_virtual_network_network_id()
        kvp_list= [
                {
                    'key': 'profile',
                    'value': '{"physical_network": "sriov"}'
                },
                {
                    'key': 'host_id',
                    'value': 'null'
                },
                {
                    'key': 'vnic_type',
                    'value': 'direct'
                },
                {
                    'key': 'vif_details',
                    'value': '{"port_filter": true, "vlan": "%d"}' %vlan_id
                },
                {
                    'key': 'vif_type',
                    'value': 'hw_veb'
                }
            ]
        kvps = vnc_api.KeyValuePairs()
        for kvp in kvp_list:
            kvps.add_key_value_pair(vnc_api.KeyValuePair(key = kvp['key'],
                    value = kvp['value']))
        vmi.set_virtual_machine_interface_bindings(kvps)
        try:
            self.vnc.virtual_machine_interface_create(vmi)
        except Exception as e:
            print 'ERROR: %s' %(str(e))
            return
        print 'VM port %s is created.' %id

        print '\n# Allocate instance IP address...'
        id = str(uuid.uuid4())
        ip = vnc_api.InstanceIp(name = id)
        ip.uuid = id
        ip.add_virtual_machine_interface(vmi)
        ip.add_virtual_network(vn_obj)
        try:
            self.vnc.instance_ip_create(ip)
        except Exception as e:
            print 'ERROR: %s' %(str(e))
            return
        ip = self.vnc.instance_ip_read(id = id)
        print 'IP address %s is allocated.' %ip.get_instance_ip_address()
        return vmi.uuid

    def launch_vm(self, name, port_id):
        print '\n# Launch VM on port %s...' %port_id
        os_args = 'server create --image centos --flavor m1.small ' + \
                '--port %s --availability-zone az-1 %s' %(port_id, name)
        self.openstack_cli(os_args)

        while (1):
            os_args = 'server show %s -c status -c id -f json' %name
            output = json.loads(self.openstack_cli(os_args))
            print 'VM State: %s' %output['status']
            if output['status'] == 'ACTIVE':
                return output['id']
            elif output['status'] == 'ERROR':
                return None
            time.sleep(5)

    def get_pf_name(self, compute, mac):
        vrouter_obj = self.vnc.virtual_router_read(
                fq_name = ['default-global-system-config', compute])
        addr = vrouter_obj.get_virtual_router_ip_address()
        ssh = paramiko.SSHClient()
        ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        ssh.connect(addr, username = compute_username,
                password = compute_password)
        stdin, stdout, stderr = ssh.exec_command('./get-pf %s' %mac)
        pf_name = stdout.read().rstrip()
        ssh.close()
        return pf_name

    def get_device_info(self, api_server, compute, pf_name):
        print '# Get device and port...'
        url = 'http://%s:8081/analytics/uves/prouters' %api_server
        response = requests.get(url)
        dev_list = response.json()
        for dev in dev_list:
            print '# Check device %s...' %dev['name']
            dev_resp = requests.get(dev['href'])
            dev_body = dev_resp.json()
            if not dev_body.has_key('PRouterLinkEntry'):
                print 'No link table.'
                continue
            link_table = dev_body['PRouterLinkEntry']['link_table']
            for link in link_table:
                if (link['remote_system_name'] == compute) and \
                        (pf_name in link['remote_interface_name']):
                    break
            else:
                continue
            break
        else:
            print 'ERROR: Not found device and port for %s!' %compute
            return None, None

        return dev['name'], link['local_interface_name']


    def create_device_port(self, args, vn_obj, vm_id, port_id):
        print '\n# Configure device port...'
        print '# Get VM port...'
        port_obj = self.vnc.virtual_machine_interface_read(id = port_id)

        bindings = port_obj.get_virtual_machine_interface_bindings()
        for kvp in bindings.get_key_value_pair():
            if kvp.key == 'host_id':
                break
        else:
            print 'ERROR: Not found "host_id" in port %s!' %port_id
            return
        compute = kvp.value
        mac = port_obj.get_virtual_machine_interface_mac_addresses().get_mac_address()[0]
        print 'Port is on compute node %s, MAC %s' %(compute, mac)

        print '# Get PF device name...'
        pf_name = self.get_pf_name(compute, mac)
        print 'PF device is %s.' %pf_name

        dev_name, dev_port = self.get_device_info(args.api_server,
                compute, pf_name)
        if not dev_name:
            print 'ERROR: Not found device for %s!' %compute
            return
        print 'device name: %s' %dev_name
        print 'device port: %s' %dev_port
        return

        id = str(uuid.uuid4())
        vmi = vnc_api.VirtualMachineInterface(name = id,
                parent_obj = self.tenant)
        vmi.uuid = id
        vmi.set_virtual_network(vn_obj)
        vm_obj = vnc_api.virtual_machine_read(id = vm_id)
        vmi.set_virtual_machine(vm_obj)
        kvp_list= [
                {
                    'key': 'profile',
                    'value': '{"physical_network": "sriov"}'
                },
                {
                    'key': 'host_id',
                    'value': 'null'
                },
                {
                    'key': 'vnic_type',
                    'value': 'direct'
                },
                {
                    'key': 'vif_details',
                    'value': '{"port_filter": true, "vlan": "10"}'
                },
                {
                    'key': 'vif_type',
                    'value': 'hw_veb'
                }
            ]
        kvps = vnc_api.KeyValuePairs()
        for kvp in kvp_list:
            kvps.add_key_value_pair(vnc_api.KeyValuePair(key = kvp['key'],
                    value = kvp['value']))
        vmi.set_virtual_machine_interface_bindings(kvps)
        try:
            self.vnc.virtual_machine_interface_create(vmi)
        except Exception as e:
            print 'ERROR: %s' %(str(e))
            return
        print 'VM port %s is created.' %id

    def cmd_launch_vm(self, args):
        print '\n# Launch SRIOV VM...'
        if not args.network:
            print 'ERROR: Argument "network" is missing!'
            return
        if args.trunk:
            print "trunk"
        else:
            vn_obj = self.update_network(args.network)
            if not vn_obj:
                return
            #port_id = self.create_vm_port(args, vn_obj)
            #if not port_id:
            #    return
            #vm_id = self.launch_vm(args.name, port_id)
            #if not vm_id:
            #    return
            vm_id = '51c6a916-b3f4-40c5-bae2-9d08e39125fd'
            port_id = 'b48e3ef7-b788-40f1-ac6e-1864c9f7d0d2'
            self.create_device_port(args, vn_obj, vm_id, port_id)

    def cmd_delete_vm(self, args):
        print '\n# Delete SRIOV VM...'
        os_args = 'server show %s -c id -f value' %args.name
        vm_id = self.openstack_cli(os_args).rstrip()
        vm = self.vnc.virtual_machine_read(id = vm_id)
        vmi_ref_list = vm.get_virtual_machine_interface_back_refs()
        os_args = 'server delete %s' %args.name
        self.openstack_cli(os_args).rstrip()
        for vmi_ref in vmi_ref_list:
            print 'Delete port %s' %vmi_ref['uuid']
            vmi = self.vnc.virtual_machine_interface_read(id = vmi_ref['uuid'])
            iip_ref_list = vmi.get_instance_ip_back_refs()
            if iip_ref_list:
                for iip_ref in iip_ref_list:
                    self.vnc.instance_ip_delete(id = iip_ref['uuid'])
            self.vnc.virtual_machine_interface_delete(id = vmi_ref['uuid'])

    def parser_init(self):
        parser = argparse.ArgumentParser()
        self.parser = parser
        parser.add_argument('--auth-username', help = 'User name')
        parser.add_argument('--auth-password', help = 'Password')
        parser.add_argument('--auth-tenant', help = 'Auth tenant name')
        parser.add_argument('--auth-domain', help = 'Auth domain name')
        parser.add_argument('--auth-region', help = 'Region name')
        parser.add_argument('--auth-server', help = 'Auth server address')
        parser.add_argument('--auth-url', help = 'Auth URL')
        parser.add_argument('--api-server', help = 'API server address')
        parser.add_argument('--domain', help = 'Domain name')
        parser.add_argument('--tenant', help = 'Tenant name')

        parser.add_argument('cmd', help = 'Command')
        parser.add_argument('name', help = 'Name')
        parser.add_argument('--network', help = 'Virtual network')
        parser.add_argument('--trunk', action = 'store_true',
                help = 'Trunk VF')

    def start(self):
        self.parser_init()
        args = self.parser.parse_args()
        #print 'args: %s' %args
        #return
        connect = ConfigConnect(args)
        if not connect.vnc:
            return
        self.vnc = connect.vnc
        self.tenant = connect.tenant
        cmd_map = {'launch-vm': self.cmd_launch_vm,
                   'delete-vm': self.cmd_delete_vm}
        func = cmd_map.get(args.cmd)
        if func:
            func(args)
        else:
            print 'ERROR: Command %s is invalid!' %args.cmd


if __name__ == '__main__':
    for arg in default_args:
        if not ('--' + arg[0]) in sys.argv:
            env_v = os.environ.get(arg[0].upper().replace('-', '_'))
            if env_v:
                arg_v = env_v
            else:
                arg_v = arg[1]
            sys.argv.insert(1, ('--' + arg[0]))
            sys.argv.insert(2, arg_v)
    SriovCli().start()

